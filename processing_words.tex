% vim: ts=4 sts=4 sw=4 et tw=75
\chapter{文本处理}
\label{chap:processing_words}

\marginpar{111}
本章的程序指向一个共同主题: 文本处理. 示例程序涵盖的范围包括随机单词
与句子的生成 (生成的句子可以和用户进行有限的对话), 以及文本处理. 大多数示例
程序都很简单, 它们只是起说明作用, 但是, 其中一些文件准备程序的确拥有实际
用途.

\section{随机文本发生器}
\label{sec:random_text_generation}

生成随机数据的程序有许多种用途. 这种程序可以用内建函数 \texttt{rand} 来
创建, 该函数每次被调用时, 都会返回一个伪随机数. \texttt{rand} 每次都使用
同一个种子数来生成随机数, 所以, 如果你想要得到一个不同的随机数序列, 你
就必须调用一次 \texttt{srand()}, 它根据当前时间计算出一个种子数, 并用
该种子数初始化 \texttt{rand}.

\subsection{随机选择}
\label{subsec:random_choices}

\texttt{rand} 每次被调用时都会返回 一个大于等于 0, 小于 1 的浮点数, 但是
一般来说, 更通常的需求是返回一个 \texttt{1} 到 \texttt{n} 之间的随机整数,
我们可以用 \texttt{rand} 来实现:
\begin{awkcode}
    # randint - return random integer x, 1 <= x <= n

    function randint(n) {
        return int(n * rand()) + 1
    }
\end{awkcode}
\texttt{randint(n)} 按比例调整 \texttt{rand} 的返回值, 调整后的值大于
等于 \texttt{0} 并且小于 \texttt{n}, 将小数部分截去可以得到 \texttt{0} 
到 \texttt{n-1} 的整数, 然后再加 1, 就是 \texttt{1} 到 \texttt{n} 之间的 
整数.

我们可以用 \texttt{randint} 来随机选择一个字母:
\marginpar{112}
\begin{awkcode}
    # randlet - generate random lower-case letter

    function randlet() {
        return substr("abcdefghijklmnopqrstuvwxyz", randint(26), 1)
    }
\end{awkcode}

利用 \texttt{randint}, 很容易就可以从一个 \texttt{n} 项的数组中随机选择一
个元素:
\begin{awkcode}
    print x[randint(n)]
\end{awkcode}
一个更有趣的问题是从某个数组中随机选择几项, 被选中的项必须按照原来的顺序
排列. 举例来说, 如果数组 \texttt{x} 按照升序排列, 则被选中的元素也要按照
升序排列.

函数 \texttt{choose} 从数组 \texttt{A} 的前 \texttt{n} 中随机选择
\texttt{k} 个元素, 并按照原来的顺序打印出来:
\begin{awkcode}
    # choose - print in order k random elements from A[1]..A[n]

    function choose(A, k, n,    i) {
        for (i = 1; n > 0; i++)
            if (rand() < k/n--) {
                print A[i]
                k--
            }
    }
\end{awkcode}
在函数内, \texttt{k} 是还需要打印的项的数目, \texttt{n} 是数组中等待检验
的元素个数. 打印第 \texttt{i} 个元素的条件是 \verb'rand() < k/n', 每当有
一个元素被打印出来, \texttt{k} 就递减一次, 每当判断条件 \verb'rand() < k/n'
被测试一次, \texttt{n} 就递减一次.

\begin{exercise}
    测试 \texttt{rand} 的输出是不是真的随机数.
\end{exercise}
\begin{exercise}
    写一个程序, 该程序生成 1 到 $n$ 之间的 $k$ 个不同的随机整数,
    程序的时间复杂 度与 $k$ 成正比.
\end{exercise}
\begin{exercise}
    写一个程序, 该程序生成随机的桥牌手 (bridge hands).
\end{exercise}

\subsection{废话生成器}
\label{subsec:cliche_generation}

我们的下一个例子是废话生成器 (cliche generator),
它根据已有的废话重新创建一个新的出来. 输入是一个句子集合:
\begin{file}
    A rolling stone:gathers no moss.
    History:repeats itself.
    He who lives by the sword:shall die by the sword.
    A jack of all trades:is master of none.
    Nature:abhors a vacuum.
    Every man:has a price.
    All's well that:ends well.
\end{file}
冒号将主语和谓语分开. 我们的废话生成器随机选择一个主语与另一个谓语作组合,
\marginpar{113}
如果运气好的话, 可能会产生很有意思的格言警句:
\begin{file}
    A rolling stone repeats itself.
    History abhors a vacuum.
    nature repeats itself.
    All's well that gathers no moss.
    He who lives by the sword has a price.
\end{file}
程序的代码实现非常明确:
\begin{awkcode}
    # cliche - generate an endless stream of cliches
    #     input:  lines of form subject:predicate
    #     output: lines of random subject and random predicate

    BEGIN { FS = ":" }
          { x[NR] = $1; y[NR] = $2 }
    END   { for (;;) print x[randint(NR)], y[randint(NR)] }

    function randint(n) { return int(n * rand()) + 1 }
\end{awkcode}
请注意, 程序中的死循环是有意为之.

\subsection{随机语句}
\label{subsec:random_sentences}

\cterm{上下文无关语法} (\term{context-free grammar}) 指的是一组规则, 这组
规则定义了如何生成或分析一个语句集合. 每一条规则 (称为 \cterm{产生式}
(\term{production})) 都具有形式:
\begin{pattern}
    \indent\indent\textit{A} $\longrightarrow$ \textit{B C D} ...
\end{pattern}
该产生式的意思是每一个 \textit{A} 都可以被 ``重写'' 为 \textit{B C D ...}.
产生式左边的符号 (\textit{A}) 称为 \cterm{非终结符} (\term{nonterminal}),
它可以被进一步地扩展. 产生式右边的符号可以是非终结符 (可以是多个
\textit{A}) 或 \cterm{终结符} (\term{terminal}), 终结符指的是不能被扩展的
符号. 多个产生式可以共享同一个非终结符, 终结符与非终结符也可以在产生式的
右边出现多次.

我们将在第 \ref{chap:little_languages} 章展示 awk 的部分语法规则, 并利用
该规则开发一个语法分析器, 用来分析 awk 程序. 然而在这一章, 我们感兴趣的是
规则的生成, 而不是分析. 举例来说, 类似 ``the boy walks slowly'' 和 ``the
girl runs very very quickly'' 这样的句子可以用下面的语法来描述:
\begin{file}
    Sentence -> Nounphrase Verbphrase
    Nounphrase -> the boy
    Nounphrase -> the girl
    Verbphrase -> Verb Modlist Adverb
    Verb -> runs
    Verb -> walks
    Modlist -> very Modlist
    Adverb -> quickly
    Adverb -> slowly
\end{file}

\marginpar{114}
如下所示, 产生式为非终结符生成语句. 假设 \texttt{Sentence} 是起始非终结符,
那么选择一条以该符号作为左部的产生式:
\begin{file}
    Sentence -> Nounphrase Verbphrase
\end{file}
接下来, 从右部选择一个非终结符, 比如说 \texttt{Nounphrase}, 然后用以
\texttt{Nounphrase} 作为左部的产生式替换掉 \texttt{Nounphrase}:
\begin{file}
    Sentence -> Nounphrase Verbphrase
             -> the boy Verbphrase
\end{file}
不断地使用该方法, 直到所有的非终结符都被替换掉为止:
\begin{file}
    Sentence -> Nounphrase Verbphrase
             -> the boy Verbphrase
             -> the bov Verb Modlist Adverb
             -> the boy walks very Modlist Adverb
             -> the boy walks very Adverb
             -> the boy walks very quickly
\end{file}
\texttt{Sentence} 的最终展开结果是一个句子. 非终结符的推导过程与我们在初
级学校所学到的语句图 (sentence-diagram) 刚好相反: 我们现在是把动词短语拆
分成动词与副词, 而不是把动词与副词组合成动词短语.

\texttt{Modlist} 的产生式比较有趣. 一条规则是说用 \texttt{very Modlist}
替换 \texttt{Modlist}, 每次使用这条规则都会使句子变长. 幸运地是, 只要运用
另一条产生式规则 (该规则用空字符串替换掉 \texttt{Modlist}) 就可以终止潜在
的无限循环.

我们现在要开发一个程序, 该程序根据语法生成语句, 每次生成都从一个指定的非
终结符开始. 程序从文件中读取语法规则, 记录下每一个左部出现的次数, 
左部所拥有的右部的个数, 以及它们各自的组成成分. 然后, 每输入一个非
终结符, 就会为该非终结符生成一个随机语句.

程序使用三个数组来存放语法规则:
\texttt{lhs[A]} 给出了非终结符 \texttt{A} 的产 
生式个数, \texttt{rhscnt[A, i]} 存放的是 \texttt{A} 的第 \texttt{i} 条产生
式右部的符号个数, \texttt{rhslist[A, i, j]} 存放的是 \texttt{A} 的第 
\texttt{i} 条产生式右部的第 \texttt{j} 个符号. 对于前面提到的语法规则, 
三个数组的内容分别是:

\begin{tabular}{ccc}

\begin{varwidth}[t]{\textwidth}
\vspace{0pt}
\begin{tikzpicture}
    \pgfmathsetmacro\height{0.5};
    \pgfmathsetmacro\maxheight{4.5};

    \foreach \i in {0,...,3}
        \draw (0, \maxheight - \i * \height) -- (1, \maxheight - \i *
        \height);
    \draw (0, \maxheight - 0) -- (0, \maxheight - 3 * \height);
    \draw (1, \maxheight - 0) -- (1, \maxheight - 3 * \height);
    \node[left] at (0, \maxheight - \height * 0.5) {\texttt{Sentence}};
    \node[left] at (0, \maxheight - \height * 1.5) {\texttt{Nounphrase}};
    \node[left] at (0, \maxheight - \height * 2.5) {\texttt{Verbphrase}};
    \node at (0.5, \maxheight - \height * 0.5) {\texttt{1}};
    \node at (0.5, \maxheight - \height * 1.5) {\texttt{2}};
    \node at (0.5, \maxheight - \height * 2.5) {\texttt{1}};
    \node at (0.5, \maxheight - \height * 3.5) {\textit{etc.}};
    \node[left] at (0, \maxheight + 0.5) {\texttt{lhs}:};
\end{tikzpicture}
\end{varwidth}
&
\begin{varwidth}[t]{\textwidth}
\vspace{0pt}
\begin{tikzpicture}
    \pgfmathsetmacro\height{0.5};
    \pgfmathsetmacro\maxheight{4.5};

    \foreach \i in {0,...,4}
        \draw (0, \maxheight - \i * \height) -- (1, \maxheight - \i *
        \height);
    \draw (0, \maxheight - 0) -- (0, \maxheight - 4 * \height);
    \draw (1, \maxheight - 0) -- (1, \maxheight - 4 * \height);
    \node[left] at (0, \maxheight - \height * 0.5) {\texttt{Sentence,1}};
    \node[left] at (0, \maxheight - \height * 1.5) {\texttt{Nounphrase,1}};
    \node[left] at (0, \maxheight - \height * 2.5) {\texttt{Nounphrase,2}};
    \node[left] at (0, \maxheight - \height * 3.5) {\texttt{Verbphrase,1}};
    \node at (0.5, \maxheight - \height * 0.5) {\texttt{2}};
    \node at (0.5, \maxheight - \height * 1.5) {\texttt{2}};
    \node at (0.5, \maxheight - \height * 2.5) {\texttt{2}};
    \node at (0.5, \maxheight - \height * 3.5) {\texttt{3}};
    \node at (0.5, \maxheight - \height * 4.5) {\textit{etc.}};
    \node at (0, \maxheight + 0.5) {\texttt{rhscnt}:};
\end{tikzpicture}
\end{varwidth}
&
\begin{varwidth}[t]{\textwidth}
\vspace{0pt}
\begin{tikzpicture}
    \pgfmathsetmacro\height{0.5};
    \pgfmathsetmacro\maxheight{4.5};

    \foreach \i in {0,...,9}
        \draw (0, \maxheight - \i * \height) -- (2.5, \maxheight - \i *
        \height);
    \draw (0, \maxheight - 0) -- (0, \maxheight - 9 * \height);
    \draw (2.5, \maxheight - 0) -- (2.5, \maxheight - 9 * \height);
    \node[left] at (0, \maxheight - \height * 0.5) {\texttt{Sentence,1,1}};
    \node[left] at (0, \maxheight - \height * 1.5) {\texttt{Sentence,1,2}};
    \node[left] at (0, \maxheight - \height * 2.5) {\texttt{Nounphrase,1,1}};
    \node[left] at (0, \maxheight - \height * 3.5) {\texttt{Nounphrase,1,2}};
    \node[left] at (0, \maxheight - \height * 4.5) {\texttt{Nounphrase,2,1}};
    \node[left] at (0, \maxheight - \height * 5.5) {\texttt{Nounphrase,2,2}};
    \node[left] at (0, \maxheight - \height * 6.5) {\texttt{Verbphrase,1,1}};
    \node[left] at (0, \maxheight - \height * 7.5) {\texttt{Verbphrase,1,2}};
    \node[left] at (0, \maxheight - \height * 8.5) {\texttt{Verbphrase,1,3}};
    \node at (1.25, \maxheight - \height * 0.5) {\texttt{Nounphrase}};
    \node at (1.25, \maxheight - \height * 1.5) {\texttt{Verbphrase}};
    \node at (1.25, \maxheight - \height * 2.5) {\texttt{the}};
    \node at (1.25, \maxheight - \height * 3.5) {\texttt{boy}};
    \node at (1.25, \maxheight - \height * 4.5) {\texttt{the}};
    \node at (1.25, \maxheight - \height * 5.5) {\texttt{girl}};
    \node at (1.25, \maxheight - \height * 6.5) {\texttt{Verb}};
    \node at (1.25, \maxheight - \height * 7.5) {\texttt{Modlist}};
    \node at (1.25, \maxheight - \height * 8.5) {\texttt{Adverb}};
    \node at (1.25, \maxheight - \height * 9.5) {\textit{etc.}};
    \node at (0, \maxheight + 0.5) {\texttt{rhslist}:};
\end{tikzpicture}
\end{varwidth}
\end{tabular}

\marginpar{115}
程序的源代码是:
\begin{awkcode}
    # sentgen - random sentence generator
    #   input:  grammar file; sequence of nonterminals
    #   output: a random sentence for each nonterminal

    BEGIN {  # read rules from grammar file
        while (getline < "grammar" > 0)
            if ($2 == "->") {
                i = ++lhs[$1]              # count lhs
                rhscnt[$1, i] = NF-2       # how many in rhs
                for (j = 3; j <= NF; j++)  # record them
                   rhslist[$1, i, j-2] = $j
            } else
                print "illegal production: " $0
    }

    {   if ($1 in lhs) {  # nonterminal to expand
            gen($1)
            printf("\n")
        } else 
            print "unknown nonterminal: " $0   
    }

    function gen(sym,    i, j) {
        if (sym in lhs) {       # a nonterminal
            i = int(lhs[sym] * rand()) + 1   # random production
            for (j = 1; j <= rhscnt[sym, i]; j++) # expand rhs's
                gen(rhslist[sym, i, j])
        } else
            printf("%s ", sym)
    }
\end{awkcode}

函数 \texttt{gen("A")} 为非终结符 \texttt{A} 生成一条语句. 如果前一次的扩展
引入了非终结符, 那么函数通过递归调用自身来展开. 请记住, 所有被递归函数用%
\marginpar{116}%
到的临时变量都需要出现在函数的参数列表中, 如果某个变量没有出现在参数列表,
那它就是全局变量, 此时程序就无法正确地工作.

我们把右部个数及其组成成分分别存放在两个数组中, 不过实际上, 不使用下标
来编码不同的字段也是有可能的, 在其他语言中可以通过记录或结构体来实现. 
举例来说, 数组 \texttt{rhscnt[i,j]} 可以是 \texttt{rhslist} 的元素,
表示成 \texttt{rhslist[i,j,"cnt"]}.\footnote{原文为 We chose to use
    separate arrays for the right-hand-side counts and components, but it
    is possible instead to use subscripts to encode different fields,
    rather like records or structures in other languages. For example, the
    array \texttt{rhscnt[i,j]} could be part of \texttt{rhslist}, as
    \texttt{rhslist[i,j,"cnt"]}.}

\begin{exercise}
    写一套语法规则, 该规则能够生成关于某学科的, 听起来貌似合理的文本 ---
    商业, 政治, 计算科学都是很好的选择.\footnote{原文为 Write a grammar for
        generating plausible-sounding text from a field that appeals to you
    -- business, politics, and computing are all good possibilities.}
\end{exercise}

\begin{exercise}
    在某些语法规则下, 语句生成程序很有可能落入到这样一种境地:
    推导过程越来越长, 却没有停下来的迹象, 添加一条机制, 使得程序可以限制
    推导过程的长度.
\end{exercise}

\begin{exercise}
    给语法规则加上权重, 使得对同一个非终结符来说, 它的各个展开规则被选中
    的概率是不同的.
\end{exercise}

\begin{exercise}
    实现一个非递归的语句生成程序.
\end{exercise}

\section{交互式的文本处理}
\label{sec:interactive_text_manipulation}

使用 awk 很容易就可以写出一个交互式程序, 我们将通过两个示例程序来阐明
基本思路. 第一个程序测试运算能力, 第二个程序测试某一特定领域的相关知识.

\subsection{技巧测试之运算}
\label{subsec:skills_testing_arithmetic}

下面的程序 \texttt{arith} (最适用于幼儿) 显示一系列加法运算问题, 比如 
\begin{file}
    7 + 9 = ?
\end{file}
在每个问题之后, 用户输入问题的答案. 如果回答是正确的, 用户就会收到一句
赞美, 然后显示下一个问题; 如果回答是错误的, 那么程序会再次请求输入答案;
如果用户没有输入答案, 那么在显示下一个问题之前, 程序输出正确答案.

调用程序的命令行有两种形式:
\begin{pattern}
    \indent\texttt{awk -f arith} \par 
    \indent\texttt{awk -f arith} \textit{n}
\end{pattern}
如果在 \texttt{arith} 之后有一个参数, 程序将使用该参数限制每个问题的数的
最大值. 该参数被读取之后, \texttt{ARGV[1]} 被设置为 \texttt{"-"},
于是程序从标准输入读取用户的回答. 如果没有指定参数, 那么数的最大值就是
10.
\marginpar{117}
\begin{awkcode}
    # arith - addition drill
    #   usage:  awk -f arith [ optional problem size ]
    #   output: queries of the form "i + j = ?"

    BEGIN {
        maxnum = ARGC > 1 ? ARGV[1] : 10   # default size is 10
        ARGV[1] = "-"  # read standard input subsequently
        srand()        # reset rand from time of day
        do {
            n1 = randint(maxnum)
            n2 = randint(maxnum)
            printf("%g + %g = ? ", n1, n2)
            while ((input = getline) > 0)
                if ($0 == n1 + n2) {
                    print "Right!"
                    break
                } else if ($0 == "") {
                    print n1 + n2
                    break
                } else
                    printf("wrong, try again: ")
        } while (input > 0)
    }

    function randint(n) { return int(rand()*n)+1 }
\end{awkcode}

\begin{exercise}
    除了加法外, 再新增几种数学运算. 另外, 如果用户的回答是错误的, 显示 
    一条提示信息.
\end{exercise}

\subsection{技巧测试之测验}
\label{subsec:skills_testing_quiz}

我们的第二个例子是程序 \texttt{quiz}, \texttt{quiz} 从题库中抽取特定的文件,
并用文件中的问题向用户提问. 例如, 我们可以测试用户对化学元素的了解程度.
假设化学元素的题库文件是 \texttt{quiz.elems}, 文件包含了化学元素的符号, 
原子序数, 以及元素的全称, 字段之间用冒号分开. 文件的第一行比较特殊, 它
标明了各个字段的意义:
\begin{file}
    symbol:number:name|element
    H:1:Hydrogen
    He:2:Helium
    Li:3:Lithium
    Be:4:Beryllium
    B:5:Boron
    C:6:Carbon
    N:7:Nitrogen
    O:8:Oxygen
    F:9:Fluorine
    Ne:10:Neon
    Na:11:Sodium|Natrium
    ...
\end{file}
程序根据第一行来判断哪个字段是问题, 哪个字段是正确答案, 然后把文件剩下的
\marginpar{118}
部分读取到一个数组中, 通过该数组, 程序就可以随机地选择问题并检查回答的
正确性. 输入命令行
\begin{shell}
    awk -f quiz quiz.elems name symbol
\end{shell}
之后, 我们将会得到类似下面的对话:
\begin{shell}
    Beryllium? B
    wrong, try again: Be
    Right!
    Fluorine?
    ...
\end{shell}
注意, 备选答案 (例如 sodium 或 natrium) 很容易通过数据文件中的正则表达
式来处理.
\begin{awkcode}
    # quiz - present a quiz
    #   usage: awk -f quiz topicfile question-subj answer-subj

    BEGIN {
        FS = ":"
        if (ARGC != 4)
            error("usage: awk -f quiz topicfile question answer")
        if (getline <ARGV[1] < 0)    # 1st line is subj:subj:...
            error("no such quiz as " ARGV[1])
        for (q = 1; q <= NF; q++)
            if ($q ~ ARGV[2])
                break
        for (a = 1; a <= NF; a++)
            if ($a ~ ARGV[3])
                break
        if (q > NF || a > NF || q == a)
            error("valid subjects are " $0)
        while (getline <ARGV[1] > 0) # load the quiz
            qa[++nq] = $0
        ARGC = 2; ARGV[1] = "-"      # now read standard input
        srand()
        do {
            split(qa[int(rand()*nq + 1)], x)
            printf("%s? ", x[q])
            while ((input = getline) > 0)
                if ($0 ~ "^(" x[a] ")$") {
                    print "Right!"
                    break
                } else if ($0 == "") {
                    print x[a]
                    break
                } else
                    printf("wrong, try again: ")
        } while (input > 0)
    }

    function error(s) { printf("error: %s\n", s); exit }
\end{awkcode}
\marginpar{119}
为了辨别出正确答案, 我们用 \texttt{\^} 和 \texttt{\$} 包围正则表达式, 否则的
话, 只要用户的回答中含有与标准答案匹配的子字符串, 那么该回答就会被认为是
正确的 (于是, \texttt{Ne}, \texttt{Na} 与 \texttt{N} 都会被当作标准答案
\texttt{N}).

\begin{exercise}
    修改 \texttt{quiz}, 使得它对于同一道问题, 最多输出一次.
\end{exercise}

\section{文本处理}
\label{sec:text_processing}

由于强大的字符串处理能力, 对于涉及到文本处理与文件准备的工作来说, awk 是
一个非常有用的工具. 作为示例, 这一节包含的程序可以用于单词计数, 文本格式
化, 交叉索引维护, 制作 KWIC 索引, 以及索引准备工作.

\subsection{单词计数}
\label{subsec:word_counts}

在第 \ref{chap:an_awk_tutorial} 章, 我们展示了一个用于计算某个文件的行数,
单词数与字符数的程序, 在该程序中, 单词被定义为由多个非空白字符组成的字
符序列. 与此相关的问题是计算某个文档中, 每个单词的出现次数, 解决这个问题
的一种思路是把文档中的单词分解出来, 对它们排序, 这样相同的单词就会紧挨在
一起, 最后再用 control-break 程序计算每个单词的出现次数.

另一种思路 (与 awk 非常契合) 是分解出每一个单词, 把单词的出现次数记录在
关联数组中. 为了更好地完成这个任务, 我们必须搞清楚一个单词究竟是由什么
组成的. 在下面的程序里, 单词是一个移除了标点符号的字段, 于是,
\texttt{"word"}, \texttt{"word;"} 以及 \texttt{"(word)"} 都看作是单词
\texttt{word}. \END 降序输出每个单词的出现次数.
\begin{awkcode}
    # wordfreq - print number of occurrences of each word
    #   input:  text
    #   output: number-word pairs sorted by number

        { gsub(/[.,:;!?(){}]/, "")    # remove punctuation
          for (i = 1; i <= NF; i++)
              count[$i]++
        }
    END { for (w in count)
              print count[w], w | "sort -rn"
        }
\end{awkcode}
本章草稿出现最多的十个单词是:
\begin{file}
    312 the     152 a       126 of      121 is      110 to
    92 and      72 in       71 The      59 at       54 that
\end{file}

\begin{exercise}
    修改单词计数程序, 使得它不区分单词大小写, 于是 \texttt{The} 与
    \texttt{the} 被当作是同一个单词.
\end{exercise}

\begin{exercise}
    写一个程序, 该程序计算某个文档中句子的个数及每个句子的长度.
\end{exercise}

\marginpar{120}
\begin{exercise}
    写一个 control-break 程序, 用来计算单词的个数. 与 \texttt{wordfreq} 
    相比, 它的性能表现如何?
\end{exercise}

\subsection{文本格式化}
\label{subsec:text_formatting}

程序 \texttt{fmt} 把它的输入格式化成每行至多 60 个字符, 基本思路是通过移动
单词, 尽可能地把每一行都塞满. 空行表示分段, 除此之外没有其他控制指令.
有些文本在创建时没有考虑到每行的长度, 可以使用 \texttt{fmt} 对这些文本
进行格式化.
\begin{awkcode}
    # fmt - format
    #    input:  text
    #    output: text formatted into lines of <= 60 characters

    /./  { for (i = 1; i <= NF; i++) addword($i) }
    /^$/ { printline(); print "" }
    END  { printline() }

    function addword(w) {
        if (length(line) + length(w) > 60)
            printline()
        line = line " " w
    }

    function printline() {
        if (length(line) > 0) {
            print substr(line, 2)   # removes leading blank
            line = ""
        }
    }
\end{awkcode}

\begin{exercise}
    修改 \texttt{fmt}, 使得它可以对齐输出文本的右边空白.
\end{exercise}

\begin{exercise}
    增强 \texttt{fmt}的功能, 使得它可以通过识别文档中可能的标题, 列表等信息,
    推断出文档的正确格式. 这次不是直接对文档进行格式化, 而是生成排版
    程序 (例如 \texttt{troff}, TEX 等) 的格式化命令.
\end{exercise}

\subsection{维护手稿的交叉引用}
\label{subsec:maintaining_cross_reference_in_manuscripts}

文件准备的一个常见问题是为条目创建一个一致的名字或数字集合, 条目可以是
文献引用, 图表, 示例等.\footnote{原文为 A common problem in document
    preparation is creating a consistent set of names or numbers for items
like bibliographic citations, figures, tables, examples, and so on.}
某些文本格式化程序可以帮助我们完成这件工作, 但是大多数情况下需要你自己来
完成. 我们的下一个例子是对交叉引用进行编号, 该技术对于技术文档编写来说
特别有用.

编写文档时, 作者为不同的条目创建并使用不同的符号名, 这些条目之后会被
交叉引用. 因为名字是符号化的, 所以条目可以被添加, 删除, 重新编排, 而不用
修改已存在的名字. 本节所提出的交叉引用技术是使用两个程序共同创建一个文本,
文本中的符号名被适当的数字
所替代\footnote{原文为 Two programs create the version in which the
symbolic names are replaced by suitable numbers. 原文显得有点突兀: 不经
过渡就直接提到 ``Two programs ...''}.
这里有一个示例文档, 文档中包含了两个文献引用和一张图的符号名:
\marginpar{121}
\begin{file}
    .#Fig _quotes_
    Figure _quotes_ gives two brief quotations from famous books.

                            Figure _quotes_:

    .#Bib _alice_
      "... `and what is the use of a book,' thought Alice,
      `without pictures or conversations?'" [_alice_]

    .#Bib _huck_
      "... if I'd a knowed what a trouble it was to make a book
      I wouldn't a tackled it and ain't agoing to no more." [_huck_]


    [_alice_] Carroll, L., Alice's Adventures in Wonderland,
        Macmillan, 1865.
    [_huck_] Twain, M., Adventures of Huckleberry Finn,
        Webster & Co., 1885.
\end{file}
每一个符号名均由下面这种形式的行来定义:
\begin{file}
    .#Category _SymbolicName_
\end{file}
这样的定义可以出现在文档中的任何地方, 只要作者愿意, 他可以定义多种不同的
\texttt{Category}. 在整篇文档中, 某一条目总是通过它的符号名来引用. 我们 
规定符号名以下划线开始并结尾, 不过你也可以使用其他任意的名字, 前提是
你可以从文本中把它们分离出来 (条目的名字不可以相同, 即使它们在不同的
类别中). 名字 \texttt{.\#Fig} 与 \texttt{.\#Big} 以句点开始, 这样的话即使
交叉引用未被解析, 格式化程序 \texttt{troff} 也可以忽略它们, 对于不同的
格式化程序, 我们可能需要作不同的约定.

转换程序创建一份新版本的文档, 在新版本中, 定义被删除, 并且每一个符号名
都被一个数字所替代. 在每一个类别中, 数字从 1 开始, 并按照原始文档中该
类别定义出现的顺序而递增. 

把文档输送给两个程序就可以完成上面所说的转换过程. 这里体现出的工作划分
思想是强大的通用编程技巧的又一个实例: 第一个程序创建第二个程序, 并让
第二个程序完成剩下的部分. 在这个案例中, 第一个程序 \texttt{xref} 扫描原始
文档并创建第二个程序 \texttt{xref.temp}, 实际的转换过程将由
\texttt{xref.temp} 来完成. 假设手稿的原版是 \texttt{document}, 只需要键入
\begin{shell}
    awk -f xref document > xref.temp
    awk -f xref.temp document
\end{shell}
就可以得到带有数字形式引用的文档. 第二个程序的输出可以被重定向到打印机
或文本格式化程序.
\marginpar{122}
上面所提到的示例文档的转换结果是:
\begin{file}
    Figure 1 gives two brief quotations from famous books.

                            Figure 1:

      "... `and what is the use of a book,' thought Alice,
      `without pictures or conversations?'" [1]

      "... if I'd a knowed what a trouble it was to make a book
      I wouldn't a tackled it and ain't agoing to no more." [2]


    [1] Carroll, L., Alice's Adventures in Wonderland,
        Macmillan, 1865.
    [2] Twain, M., Adventures of Huckleberry Finn,
        Webster & Co., 1885.
\end{file}

程序 \texttt{xref} 在文档中搜索以 \texttt{.\#} 开始的行, 对该行的每一次
出现, 程序都会递增数组 \texttt{count} 中与该类别对应的元素的值, 然后打印
一条 \texttt{gsub} 语句.
\begin{awkcode}
    # xref - create numeric values for symbolic names
    #    input:  text with definitions for symbolic names
    #    output: awk program to replace symbolic names by numbers

    /^\.#/ { printf("{ gsub(/%s/, \"%d\") }\n", $2, ++count[$1]) }
    END    { printf("!/^[.]#/\n") }
\end{awkcode}
对于文件 \texttt{document}, \texttt{xref} 输出的是第二个程序
\texttt{xref.temp}:
\begin{awkcode}
    { gsub(/_quotes_/, "1") }
    { gsub(/_alice_/, "1") }
    { gsub(/_huck_/, "2") }
    !/^[.]#/
\end{awkcode}
\texttt{gsub} 把符号名全局性地替换成数字, 最后一条语句忽略以 \texttt{.\#}
开始的行, 从而删除掉符号名定义.

\begin{exercise}
    如果符号名末尾的下划线被不小心遗漏了, 会发生什么事?
\end{exercise}

\begin{exercise}
    修改 \texttt{xref}, 使得它可以侦测到某个符号名的多次定义
\end{exercise}

\begin{exercise}
    修改 \texttt{xref}, 使得它可以生成你所喜爱的文本编辑器或流式编辑器
    (比如 \texttt{sed}) 的编辑命令, 而非awk命令. 这会对编辑器的性能产生
    什么影响 ?
\end{exercise}

\begin{exercise}
    你有没有办法使得 \texttt{xref} 只需要对输入数据遍历一次 ? ``遍历一次''
    对定义的放置位置而言, 隐含着什么限制条件?
\end{exercise}

\subsection{制作 KWIC 索引}
\label{subsec:making_a_kwic_index}

一个 KWIC (Keyword-In-Context) 索引指的是一种显示了其所在行的上下文内的每
一个单词的索引\footnote{原文为 A Keyword-In-Context or KWIC index is an
index that shows each word in the context of the line it is found in.}.
在本质上, 它所提供的信息等价于重要语汇索引 (concordance), 虽然形式上有点
不同. 考虑下面三个句子
